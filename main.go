// Package neon provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.0 DO NOT EDIT.
package neon

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for BillingSubscriptionType.
const (
	Enterprise          BillingSubscriptionType = "enterprise"
	Free                BillingSubscriptionType = "free"
	PlatformPartnership BillingSubscriptionType = "platform_partnership"
	Pro                 BillingSubscriptionType = "pro"
	UNKNOWN             BillingSubscriptionType = "UNKNOWN"
)

// Defines values for BranchState.
const (
	BranchStateInit  BranchState = "init"
	BranchStateReady BranchState = "ready"
)

// Defines values for EndpointPoolerMode.
const (
	Transaction EndpointPoolerMode = "transaction"
)

// Defines values for EndpointState.
const (
	EndpointStateActive EndpointState = "active"
	EndpointStateIdle   EndpointState = "idle"
	EndpointStateInit   EndpointState = "init"
)

// Defines values for EndpointType.
const (
	ReadOnly  EndpointType = "read_only"
	ReadWrite EndpointType = "read_write"
)

// Defines values for OperationAction.
const (
	ApplyConfig        OperationAction = "apply_config"
	ApplyStorageConfig OperationAction = "apply_storage_config"
	CheckAvailability  OperationAction = "check_availability"
	CreateBranch       OperationAction = "create_branch"
	CreateCompute      OperationAction = "create_compute"
	CreateTimeline     OperationAction = "create_timeline"
	DeleteTimeline     OperationAction = "delete_timeline"
	DisableMaintenance OperationAction = "disable_maintenance"
	ReplaceSafekeeper  OperationAction = "replace_safekeeper"
	StartCompute       OperationAction = "start_compute"
	SuspendCompute     OperationAction = "suspend_compute"
	TenantAttach       OperationAction = "tenant_attach"
	TenantDetach       OperationAction = "tenant_detach"
	TenantIgnore       OperationAction = "tenant_ignore"
	TenantReattach     OperationAction = "tenant_reattach"
)

// Defines values for OperationStatus.
const (
	Failed     OperationStatus = "failed"
	Finished   OperationStatus = "finished"
	Running    OperationStatus = "running"
	Scheduling OperationStatus = "scheduling"
)

// Defines values for Provisioner.
const (
	K8sNeonvm Provisioner = "k8s-neonvm"
	K8sPod    Provisioner = "k8s-pod"
)

// ApiKeyCreateRequest defines model for ApiKeyCreateRequest.
type ApiKeyCreateRequest struct {
	// KeyName A user-specified API key name. This value is required when creating an API key.
	KeyName string `json:"key_name"`
}

// ApiKeyCreateResponse defines model for ApiKeyCreateResponse.
type ApiKeyCreateResponse struct {
	// Id The API key ID
	Id int64 `json:"id"`

	// Key The generated 64-bit token required to access the Neon API
	Key string `json:"key"`
}

// ApiKeyRevokeResponse defines model for ApiKeyRevokeResponse.
type ApiKeyRevokeResponse struct {
	// Id The API key ID
	Id int64 `json:"id"`

	// LastUsedAt A timestamp indicating when the API was last used
	LastUsedAt *time.Time `json:"last_used_at"`

	// LastUsedFromAddr The IP address from which the API key was last used
	LastUsedFromAddr string `json:"last_used_from_addr"`

	// Name The user-specified API key name
	Name string `json:"name"`

	// Revoked A `true` or `false` value indicating whether the API key is revoked
	Revoked bool `json:"revoked"`
}

// ApiKeysListResponseItem defines model for ApiKeysListResponseItem.
type ApiKeysListResponseItem struct {
	// CreatedAt A timestamp indicating when the API key was created
	CreatedAt time.Time `json:"created_at"`

	// Id The API key ID
	Id int64 `json:"id"`

	// LastUsedAt A timestamp indicating when the API was last used
	LastUsedAt *time.Time `json:"last_used_at"`

	// LastUsedFromAddr The IP address from which the API key was last used
	LastUsedFromAddr string `json:"last_used_from_addr"`

	// Name The user-specified API key name
	Name string `json:"name"`
}

// BillingSubscriptionType Type of subscription to Neon Cloud.
// Notice that for users without billing account this will be "UNKNOWN"
type BillingSubscriptionType string

// Branch defines model for Branch.
type Branch struct {
	ActiveTimeSeconds  int64 `json:"active_time_seconds"`
	ComputeTimeSeconds int64 `json:"compute_time_seconds"`

	// CpuUsedSec CPU seconds used by all the endpoints of the branch, including deleted ones.
	// This value is reset at the beginning of each billing period.
	// Examples:
	// 1. A branch that uses 1 CPU for 1 second is equal to `cpu_used_sec=1`.
	// 2. A branch that uses 2 CPUs simultaneously for 1 second is equal to `cpu_used_sec=2`.
	// Deprecated:
	CpuUsedSec int64 `json:"cpu_used_sec"`

	// CreatedAt A timestamp indicating when the branch was created
	CreatedAt time.Time `json:"created_at"`

	// CreationSource The branch creation source
	CreationSource string `json:"creation_source"`

	// CurrentState The branch state
	CurrentState      BranchState `json:"current_state"`
	DataTransferBytes int64       `json:"data_transfer_bytes"`

	// Id The branch ID. This value is generated when a branch is created. A `branch_id` value has a `br` prefix. For example: `br-small-term-683261`.
	Id string `json:"id"`

	// LogicalSize The logical size of the branch, in bytes
	LogicalSize *int64 `json:"logical_size,omitempty"`

	// Name The branch name
	Name string `json:"name"`

	// ParentId The `branch_id` of the parent branch
	ParentId *string `json:"parent_id,omitempty"`

	// ParentLsn The Log Sequence Number (LSN) on the parent branch from which this branch was created
	ParentLsn *string `json:"parent_lsn,omitempty"`

	// ParentTimestamp The point in time on the parent branch from which this branch was created
	ParentTimestamp *time.Time `json:"parent_timestamp,omitempty"`

	// PendingState The branch state
	PendingState *BranchState `json:"pending_state,omitempty"`

	// Primary Whether the branch is the project's primary branch
	Primary bool `json:"primary"`

	// ProjectId The ID of the project to which the branch belongs
	ProjectId string `json:"project_id"`

	// UpdatedAt A timestamp indicating when the branch was last updated
	UpdatedAt        time.Time `json:"updated_at"`
	WrittenDataBytes int64     `json:"written_data_bytes"`
}

// BranchCreateRequest defines model for BranchCreateRequest.
type BranchCreateRequest struct {
	Branch *struct {
		// Name The branch name
		Name *string `json:"name,omitempty"`

		// ParentId The `branch_id` of the parent branch
		ParentId *string `json:"parent_id,omitempty"`

		// ParentLsn A Log Sequence Number (LSN) on the parent branch. The branch will be created with data from this LSN.
		ParentLsn *string `json:"parent_lsn,omitempty"`

		// ParentTimestamp A timestamp identifying a point in time on the parent branch. The branch will be created with data starting from this point in time.
		ParentTimestamp *time.Time `json:"parent_timestamp,omitempty"`
	} `json:"branch,omitempty"`
	Endpoints *[]BranchCreateRequestEndpointOptions `json:"endpoints,omitempty"`
}

// BranchCreateRequestEndpointOptions defines model for BranchCreateRequestEndpointOptions.
type BranchCreateRequestEndpointOptions struct {
	AutoscalingLimitMaxCu *ComputeUnit `json:"autoscaling_limit_max_cu,omitempty"`
	AutoscalingLimitMinCu *ComputeUnit `json:"autoscaling_limit_min_cu,omitempty"`

	// Provisioner The Neon compute provisioner. Select the `k8s-neonvm` provisioner to enable autoscaling.
	Provisioner *Provisioner `json:"provisioner,omitempty"`

	// SuspendTimeoutSeconds Duration of inactivity in seconds after which the cimpute endpoint is
	// automatically suspended. The value `0` means use the global default.
	// The value `-1` means never suspend. The default value is `300` seconds (5 minutes).
	// The maximum value is `604800` seconds (1 week). For more information, see
	// [Auto-suspend configuration](https://neon.tech/docs/manage/endpoints#auto-suspend-configuration).
	SuspendTimeoutSeconds *SuspendTimeoutSeconds `json:"suspend_timeout_seconds,omitempty"`

	// Type The compute endpoint type. Either `read_write` or `read_only`.
	// The `read_only` compute endpoint type is not yet supported.
	Type EndpointType `json:"type"`
}

// BranchOperations defines model for BranchOperations.
type BranchOperations struct {
	Branch     Branch      `json:"branch"`
	Operations []Operation `json:"operations"`
}

// BranchResponse defines model for BranchResponse.
type BranchResponse struct {
	Branch Branch `json:"branch"`
}

// BranchState The branch state
type BranchState string

// BranchUpdateRequest defines model for BranchUpdateRequest.
type BranchUpdateRequest struct {
	Branch struct {
		Name *string `json:"name,omitempty"`
	} `json:"branch"`
}

// BranchesResponse defines model for BranchesResponse.
type BranchesResponse struct {
	Branches []Branch `json:"branches"`
}

// ComputeUnit defines model for ComputeUnit.
type ComputeUnit = float32

// ConnectionDetails defines model for ConnectionDetails.
type ConnectionDetails struct {
	ConnectionParameters ConnectionParameters `json:"connection_parameters"`

	// ConnectionUri Connection URI is same as specified in https://www.postgresql.org/docs/current/libpq-connect.html#id-1.7.3.8.3.6
	// It is a ready to use string for psql or for DATABASE_URL environment variable.
	ConnectionUri string `json:"connection_uri"`
}

// ConnectionParameters defines model for ConnectionParameters.
type ConnectionParameters struct {
	// Database Database name.
	Database string `json:"database"`

	// Host Host name.
	Host string `json:"host"`

	// Password Password for the role.
	Password string `json:"password"`

	// PoolerHost Pooler host name.
	PoolerHost string `json:"pooler_host"`

	// Role Role name.
	Role string `json:"role"`
}

// ConnectionURIsOptionalResponse defines model for ConnectionURIsOptionalResponse.
type ConnectionURIsOptionalResponse struct {
	ConnectionUris *[]ConnectionDetails `json:"connection_uris,omitempty"`
}

// ConnectionURIsResponse defines model for ConnectionURIsResponse.
type ConnectionURIsResponse struct {
	ConnectionUris []ConnectionDetails `json:"connection_uris"`
}

// Database defines model for Database.
type Database struct {
	// BranchId The ID of the branch to which the database belongs
	BranchId string `json:"branch_id"`

	// CreatedAt A timestamp indicating when the database was created
	CreatedAt time.Time `json:"created_at"`

	// Id The database ID
	Id int64 `json:"id"`

	// Name The database name
	Name string `json:"name"`

	// OwnerName The name of role that owns the database
	OwnerName string `json:"owner_name"`

	// UpdatedAt A timestamp indicating when the database was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// DatabaseCreateRequest defines model for DatabaseCreateRequest.
type DatabaseCreateRequest struct {
	Database struct {
		// Name The name of the datbase
		Name string `json:"name"`

		// OwnerName The name of the role that owns the database
		OwnerName string `json:"owner_name"`
	} `json:"database"`
}

// DatabaseOperations defines model for DatabaseOperations.
type DatabaseOperations struct {
	Database   Database    `json:"database"`
	Operations []Operation `json:"operations"`
}

// DatabaseResponse defines model for DatabaseResponse.
type DatabaseResponse struct {
	Database Database `json:"database"`
}

// DatabaseUpdateRequest defines model for DatabaseUpdateRequest.
type DatabaseUpdateRequest struct {
	Database struct {
		// Name The name of the database
		Name *string `json:"name,omitempty"`

		// OwnerName The name of the role that owns the database
		OwnerName *string `json:"owner_name,omitempty"`
	} `json:"database"`
}

// DatabasesResponse defines model for DatabasesResponse.
type DatabasesResponse struct {
	Databases []Database `json:"databases"`
}

// DefaultEndpointSettings A collection of settings for a Neon endpoint
type DefaultEndpointSettings struct {
	AutoscalingLimitMaxCu *ComputeUnit `json:"autoscaling_limit_max_cu,omitempty"`
	AutoscalingLimitMinCu *ComputeUnit `json:"autoscaling_limit_min_cu,omitempty"`

	// PgSettings A raw representation of PostgreSQL settings
	PgSettings *PgSettingsData `json:"pg_settings,omitempty"`

	// SuspendTimeoutSeconds Duration of inactivity in seconds after which the cimpute endpoint is
	// automatically suspended. The value `0` means use the global default.
	// The value `-1` means never suspend. The default value is `300` seconds (5 minutes).
	// The maximum value is `604800` seconds (1 week). For more information, see
	// [Auto-suspend configuration](https://neon.tech/docs/manage/endpoints#auto-suspend-configuration).
	SuspendTimeoutSeconds *SuspendTimeoutSeconds `json:"suspend_timeout_seconds,omitempty"`
	AdditionalProperties  map[string]string      `json:"-"`
}

// Endpoint defines model for Endpoint.
type Endpoint struct {
	AutoscalingLimitMaxCu ComputeUnit `json:"autoscaling_limit_max_cu"`
	AutoscalingLimitMinCu ComputeUnit `json:"autoscaling_limit_min_cu"`

	// BranchId The ID of the branch that the compute endpoint is associated with
	BranchId string `json:"branch_id"`

	// CreatedAt A timestamp indicating when the compute endpoint was created
	CreatedAt time.Time `json:"created_at"`

	// CreationSource The compute endpoint creation source
	CreationSource string `json:"creation_source"`

	// CurrentState The state of the compute endpoint
	CurrentState EndpointState `json:"current_state"`

	// Disabled Whether to restrict connections to the compute endpoint
	Disabled bool `json:"disabled"`

	// Host The hostname of the compute endpoint. This is the hostname specified when connecting to a Neon database.
	Host string `json:"host"`

	// Id The compute endpoint ID. Compute endpoint IDs have an `ep-` prefix. For example: `ep-little-smoke-851426`
	Id string `json:"id"`

	// LastActive A timestamp indicating when the compute endpoint was last active
	LastActive *time.Time `json:"last_active,omitempty"`

	// PasswordlessAccess Whether to permit passwordless access to the compute endpoint
	PasswordlessAccess bool `json:"passwordless_access"`

	// PendingState The state of the compute endpoint
	PendingState *EndpointState `json:"pending_state,omitempty"`

	// PoolerEnabled Whether connection pooling is enabled for the compute endpoint
	PoolerEnabled bool `json:"pooler_enabled"`

	// PoolerMode The connection pooler mode. Neon supports PgBouncer in `transaction` mode only.
	PoolerMode EndpointPoolerMode `json:"pooler_mode"`

	// ProjectId The ID of the project to which the compute endpoint belongs
	ProjectId string `json:"project_id"`

	// Provisioner The Neon compute provisioner. Select the `k8s-neonvm` provisioner to enable autoscaling.
	Provisioner Provisioner `json:"provisioner"`

	// ProxyHost DEPRECATED. Use the "host" property instead.
	ProxyHost string `json:"proxy_host"`

	// RegionId The region identifier
	RegionId string `json:"region_id"`

	// Settings A collection of settings for a compute endpoint
	Settings EndpointSettingsData `json:"settings"`

	// SuspendTimeoutSeconds Duration of inactivity in seconds after which the cimpute endpoint is
	// automatically suspended. The value `0` means use the global default.
	// The value `-1` means never suspend. The default value is `300` seconds (5 minutes).
	// The maximum value is `604800` seconds (1 week). For more information, see
	// [Auto-suspend configuration](https://neon.tech/docs/manage/endpoints#auto-suspend-configuration).
	SuspendTimeoutSeconds SuspendTimeoutSeconds `json:"suspend_timeout_seconds"`

	// Type The compute endpoint type. Either `read_write` or `read_only`.
	// The `read_only` compute endpoint type is not yet supported.
	Type EndpointType `json:"type"`

	// UpdatedAt A timestamp indicating when the compute endpoint was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// EndpointCreateRequest defines model for EndpointCreateRequest.
type EndpointCreateRequest struct {
	Endpoint struct {
		AutoscalingLimitMaxCu *ComputeUnit `json:"autoscaling_limit_max_cu,omitempty"`
		AutoscalingLimitMinCu *ComputeUnit `json:"autoscaling_limit_min_cu,omitempty"`

		// BranchId The ID of the branch the compute endpoint will be associated with
		BranchId string `json:"branch_id"`

		// Disabled Whether to restrict connections to the compute endpoint
		Disabled *bool `json:"disabled,omitempty"`

		// PasswordlessAccess NOT YET IMPLEMENTED. Whether to permit passwordless access to the compute endpoint.
		PasswordlessAccess *bool `json:"passwordless_access,omitempty"`

		// PoolerEnabled Whether to enable connection pooling for the compute endpoint
		PoolerEnabled *bool `json:"pooler_enabled,omitempty"`

		// PoolerMode The connection pooler mode. Neon supports PgBouncer in `transaction` mode only.
		PoolerMode *EndpointPoolerMode `json:"pooler_mode,omitempty"`

		// Provisioner The Neon compute provisioner. Select the `k8s-neonvm` provisioner to enable autoscaling.
		Provisioner *Provisioner `json:"provisioner,omitempty"`

		// RegionId The region where the compute endpoint will be created. Only the project's `region_id` is permitted.
		RegionId *string `json:"region_id,omitempty"`

		// Settings A collection of settings for a compute endpoint
		Settings *EndpointSettingsData `json:"settings,omitempty"`

		// SuspendTimeoutSeconds Duration of inactivity in seconds after which the cimpute endpoint is
		// automatically suspended. The value `0` means use the global default.
		// The value `-1` means never suspend. The default value is `300` seconds (5 minutes).
		// The maximum value is `604800` seconds (1 week). For more information, see
		// [Auto-suspend configuration](https://neon.tech/docs/manage/endpoints#auto-suspend-configuration).
		SuspendTimeoutSeconds *SuspendTimeoutSeconds `json:"suspend_timeout_seconds,omitempty"`

		// Type The compute endpoint type. Either `read_write` or `read_only`.
		// The `read_only` compute endpoint type is not yet supported.
		Type EndpointType `json:"type"`
	} `json:"endpoint"`
}

// EndpointOperations defines model for EndpointOperations.
type EndpointOperations struct {
	Endpoint   Endpoint    `json:"endpoint"`
	Operations []Operation `json:"operations"`
}

// EndpointPoolerMode The connection pooler mode. Neon supports PgBouncer in `transaction` mode only.
type EndpointPoolerMode string

// EndpointResponse defines model for EndpointResponse.
type EndpointResponse struct {
	Endpoint Endpoint `json:"endpoint"`
}

// EndpointSettingsData A collection of settings for a compute endpoint
type EndpointSettingsData struct {
	// PgSettings A raw representation of PostgreSQL settings
	PgSettings *PgSettingsData `json:"pg_settings,omitempty"`
}

// EndpointState The state of the compute endpoint
type EndpointState string

// EndpointType The compute endpoint type. Either `read_write` or `read_only`.
// The `read_only` compute endpoint type is not yet supported.
type EndpointType string

// EndpointUpdateRequest defines model for EndpointUpdateRequest.
type EndpointUpdateRequest struct {
	Endpoint struct {
		AutoscalingLimitMaxCu *ComputeUnit `json:"autoscaling_limit_max_cu,omitempty"`
		AutoscalingLimitMinCu *ComputeUnit `json:"autoscaling_limit_min_cu,omitempty"`

		// BranchId The destination branch ID. The destination branch must not have an exsiting read-write endpoint.
		BranchId *string `json:"branch_id,omitempty"`

		// Disabled Whether to restrict connections to the compute endpoint
		Disabled *bool `json:"disabled,omitempty"`

		// PasswordlessAccess NOT YET IMPLEMENTED. Whether to permit passwordless access to the compute endpoint.
		PasswordlessAccess *bool `json:"passwordless_access,omitempty"`

		// PoolerEnabled Whether to enable connection pooling for the compute endpoint
		PoolerEnabled *bool `json:"pooler_enabled,omitempty"`

		// PoolerMode The connection pooler mode. Neon supports PgBouncer in `transaction` mode only.
		PoolerMode *EndpointPoolerMode `json:"pooler_mode,omitempty"`

		// Provisioner The Neon compute provisioner. Select the `k8s-neonvm` provisioner to enable autoscaling.
		Provisioner *Provisioner `json:"provisioner,omitempty"`

		// Settings A collection of settings for a compute endpoint
		Settings *EndpointSettingsData `json:"settings,omitempty"`

		// SuspendTimeoutSeconds Duration of inactivity in seconds after which the cimpute endpoint is
		// automatically suspended. The value `0` means use the global default.
		// The value `-1` means never suspend. The default value is `300` seconds (5 minutes).
		// The maximum value is `604800` seconds (1 week). For more information, see
		// [Auto-suspend configuration](https://neon.tech/docs/manage/endpoints#auto-suspend-configuration).
		SuspendTimeoutSeconds *SuspendTimeoutSeconds `json:"suspend_timeout_seconds,omitempty"`
	} `json:"endpoint"`
}

// EndpointsResponse defines model for EndpointsResponse.
type EndpointsResponse struct {
	Endpoints []Endpoint `json:"endpoints"`
}

// ErrorCode defines model for ErrorCode.
type ErrorCode = string

// GeneralError General Error
type GeneralError struct {
	Code ErrorCode `json:"code"`

	// Message Error message
	Message string `json:"message"`
}

// Operation defines model for Operation.
type Operation struct {
	// Action The action performed by the operation
	Action OperationAction `json:"action"`

	// BranchId The branch ID
	BranchId *string `json:"branch_id,omitempty"`

	// CreatedAt A timestamp indicating when the operation was created
	CreatedAt time.Time `json:"created_at"`

	// EndpointId The endpoint ID
	EndpointId *string `json:"endpoint_id,omitempty"`

	// Error The error that occured
	Error *string `json:"error,omitempty"`

	// FailuresCount The number of times the operation failed
	FailuresCount int32 `json:"failures_count"`

	// Id The operation ID
	Id openapi_types.UUID `json:"id"`

	// ProjectId The Neon project ID
	ProjectId string `json:"project_id"`

	// RetryAt A timestamp indicating when the operation was last retried
	RetryAt *time.Time `json:"retry_at,omitempty"`

	// Status The status of the operation
	Status OperationStatus `json:"status"`

	// UpdatedAt A timestamp indicating when the operation status was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// OperationAction The action performed by the operation
type OperationAction string

// OperationResponse defines model for OperationResponse.
type OperationResponse struct {
	Operation Operation `json:"operation"`
}

// OperationStatus The status of the operation
type OperationStatus string

// OperationsResponse defines model for OperationsResponse.
type OperationsResponse struct {
	Operations []Operation `json:"operations"`
}

// Pagination Cursor based pagination is used. The user must pass the cursor as is to the backend.
// For more information about cursor based pagination, see
// https://learn.microsoft.com/en-us/ef/core/querying/pagination#keyset-pagination
type Pagination struct {
	Cursor string `json:"cursor"`
}

// PaginationResponse defines model for PaginationResponse.
type PaginationResponse struct {
	// Pagination Cursor based pagination is used. The user must pass the cursor as is to the backend.
	// For more information about cursor based pagination, see
	// https://learn.microsoft.com/en-us/ef/core/querying/pagination#keyset-pagination
	Pagination *Pagination `json:"pagination,omitempty"`
}

// PgSettingsData A raw representation of PostgreSQL settings
type PgSettingsData map[string]string

// PgVersion The major PostgreSQL version number. Currently supported version are `14` and `15`.
type PgVersion = int

// Project defines model for Project.
type Project struct {
	// ActiveTimeSeconds Seconds. Control plane observed endpoints of this project being active this amount of wall-clock time.
	// The value has some lag.
	// The value is reset at the beginning of each billing period.
	ActiveTimeSeconds int64 `json:"active_time_seconds"`

	// BranchLogicalSizeLimit The logical size limit for a branch. The value is in MiB.
	BranchLogicalSizeLimit int64 `json:"branch_logical_size_limit"`

	// BranchLogicalSizeLimitBytes The logical size limit for a branch. The value is in B.
	BranchLogicalSizeLimitBytes int64 `json:"branch_logical_size_limit_bytes"`

	// ComputeTimeSeconds Seconds. The number of CPU seconds used by the project's compute endpoints, including compute endpoints that have been deleted.
	// The value has some lag. The value is reset at the beginning of each billing period.
	// Examples:
	// 1. An endpoint that uses 1 CPU for 1 second is equal to `compute_time=1`.
	// 2. An endpoint that uses 2 CPUs simultaneously for 1 second is equal to `compute_time=2`.
	ComputeTimeSeconds int64 `json:"compute_time_seconds"`

	// ConsumptionPeriodEnd A date-time indicating when Neon Cloud plans to stop measuring consumption for current consumption period.
	ConsumptionPeriodEnd time.Time `json:"consumption_period_end"`

	// ConsumptionPeriodStart A date-time indicating when Neon Cloud started measuring consumption for current consumption period.
	ConsumptionPeriodStart time.Time `json:"consumption_period_start"`

	// CpuUsedSec DEPRECATED, use compute_time instead.
	// Deprecated:
	CpuUsedSec int64 `json:"cpu_used_sec"`

	// CreatedAt A timestamp indicating when the project was created
	CreatedAt time.Time `json:"created_at"`

	// CreationSource The project creation source
	CreationSource string `json:"creation_source"`

	// DataStorageBytesHour Bytes-Hour. Project consumed that much storage hourly during the billing period. The value has some lag.
	// The value is reset at the beginning of each billing period.
	DataStorageBytesHour int64 `json:"data_storage_bytes_hour"`

	// DataTransferBytes Bytes. Egress traffic from the Neon cloud to the client for given project over the billing period.
	// Includes deleted endpoints. The value has some lag. The value is reset at the beginning of each billing period.
	DataTransferBytes int64 `json:"data_transfer_bytes"`

	// DefaultEndpointSettings A collection of settings for a Neon endpoint
	DefaultEndpointSettings *DefaultEndpointSettings `json:"default_endpoint_settings,omitempty"`

	// HistoryRetentionSeconds The number of seconds to retain point-in-time restore (PITR) backup history for this project.
	HistoryRetentionSeconds int64 `json:"history_retention_seconds"`

	// Id The project ID
	Id string `json:"id"`

	// MaintenanceStartsAt A timestamp indicating when project maintenance begins. If set, the project is placed into maintenance mode at this time.
	MaintenanceStartsAt *time.Time `json:"maintenance_starts_at,omitempty"`

	// Name The project name
	Name    string            `json:"name"`
	Owner   *ProjectOwnerData `json:"owner,omitempty"`
	OwnerId string            `json:"owner_id"`

	// PgVersion The major PostgreSQL version number. Currently supported version are `14` and `15`.
	PgVersion PgVersion `json:"pg_version"`

	// PlatformId The cloud platform identifier. Currently, only AWS is supported, for which the identifier is `aws`.
	PlatformId string `json:"platform_id"`

	// Provisioner The Neon compute provisioner. Select the `k8s-neonvm` provisioner to enable autoscaling.
	Provisioner Provisioner `json:"provisioner"`

	// ProxyHost The proxy host for the project. This value combines the `region_id`, the `platform_id`, and the Neon domain (`neon.tech`).
	ProxyHost string `json:"proxy_host"`

	// QuotaResetAt DEPRECATED. Use `consumption_period_end` from the getProject endpoint instead.
	// A timestamp indicating when the project quota resets
	// Deprecated:
	QuotaResetAt *time.Time `json:"quota_reset_at,omitempty"`

	// RegionId The region identifier
	RegionId string               `json:"region_id"`
	Settings *ProjectSettingsData `json:"settings,omitempty"`

	// StorePasswords Whether or not passwords are stored for roles in the Neon project. Storing passwords facilitates access to Neon features that require authorization.
	StorePasswords bool `json:"store_passwords"`

	// SyntheticStorageSize Experimental. Do not use this field yet.
	// The data storage size in bytes.
	SyntheticStorageSize *int64 `json:"synthetic_storage_size,omitempty"`

	// UpdatedAt A timestamp indicating when the project was last updated
	UpdatedAt time.Time `json:"updated_at"`

	// WrittenDataBytes Bytes. Amount of WAL that travelled through storage for given project across all branches.
	// The value has some lag. The value is reset at the beginning of each billing period.
	WrittenDataBytes int64 `json:"written_data_bytes"`
}

// ProjectCreateRequest defines model for ProjectCreateRequest.
type ProjectCreateRequest struct {
	Project struct {
		AutoscalingLimitMaxCu *ComputeUnit `json:"autoscaling_limit_max_cu,omitempty"`
		AutoscalingLimitMinCu *ComputeUnit `json:"autoscaling_limit_min_cu,omitempty"`
		Branch                *struct {
			// DatabaseName The database name. If not specified, the default database name will be used.
			DatabaseName *string `json:"database_name,omitempty"`

			// Name The branch name. If not specified, the default branch name will be used.
			Name *string `json:"name,omitempty"`

			// RoleName The role name. If not specified, the default role name will be used.
			RoleName *string `json:"role_name,omitempty"`
		} `json:"branch,omitempty"`

		// DefaultEndpointSettings A collection of settings for a Neon endpoint
		DefaultEndpointSettings *DefaultEndpointSettings `json:"default_endpoint_settings,omitempty"`

		// HistoryRetentionSeconds The number of seconds to retain the point-in-time restore (PITR) backup history for this project.
		// The default is 604800 seconds (7 days).
		HistoryRetentionSeconds *int64 `json:"history_retention_seconds,omitempty"`

		// Name The project name
		Name *string `json:"name,omitempty"`

		// PgVersion The major PostgreSQL version number. Currently supported version are `14` and `15`.
		PgVersion *PgVersion `json:"pg_version,omitempty"`

		// Provisioner The Neon compute provisioner. Select the `k8s-neonvm` provisioner to enable autoscaling.
		Provisioner *Provisioner `json:"provisioner,omitempty"`

		// RegionId The region identifier. Refer to our [Regions](https://neon.tech/docs/introduction/regions) documentation for supported regions. Values are specified in this format: `aws-us-east-1`
		RegionId *string              `json:"region_id,omitempty"`
		Settings *ProjectSettingsData `json:"settings,omitempty"`

		// StorePasswords Whether or not passwords are stored for roles in the Neon project. Storing passwords facilitates access to Neon features that require authorization.
		StorePasswords *bool `json:"store_passwords,omitempty"`
	} `json:"project"`
}

// ProjectListItem Essential data about the project. Full data is available at the getProject endpoint.
type ProjectListItem struct {
	// ActiveTime Control plane observed endpoints of this project being active this amount of wall-clock time.
	ActiveTime int64 `json:"active_time"`

	// BranchLogicalSizeLimit The logical size limit for a branch. The value is in MiB.
	BranchLogicalSizeLimit int64 `json:"branch_logical_size_limit"`

	// BranchLogicalSizeLimitBytes The logical size limit for a branch. The value is in B.
	BranchLogicalSizeLimitBytes int64 `json:"branch_logical_size_limit_bytes"`

	// CpuUsedSec DEPRECATED, use data from the getProject endpoint instead.
	// Deprecated:
	CpuUsedSec int64 `json:"cpu_used_sec"`

	// CreatedAt A timestamp indicating when the project was created
	CreatedAt time.Time `json:"created_at"`

	// CreationSource The project creation source
	CreationSource string `json:"creation_source"`

	// DefaultEndpointSettings A collection of settings for a Neon endpoint
	DefaultEndpointSettings *DefaultEndpointSettings `json:"default_endpoint_settings,omitempty"`

	// Id The project ID
	Id string `json:"id"`

	// MaintenanceStartsAt A timestamp indicating when project maintenance begins. If set, the project is placed into maintenance mode at this time.
	MaintenanceStartsAt *time.Time `json:"maintenance_starts_at,omitempty"`

	// Name The project name
	Name    string `json:"name"`
	OwnerId string `json:"owner_id"`

	// PgVersion The major PostgreSQL version number. Currently supported version are `14` and `15`.
	PgVersion PgVersion `json:"pg_version"`

	// PlatformId The cloud platform identifier. Currently, only AWS is supported, for which the identifier is `aws`.
	PlatformId string `json:"platform_id"`

	// Provisioner The Neon compute provisioner. Select the `k8s-neonvm` provisioner to enable autoscaling.
	Provisioner Provisioner `json:"provisioner"`

	// ProxyHost The proxy host for the project. This value combines the `region_id`, the `platform_id`, and the Neon domain (`neon.tech`).
	ProxyHost string `json:"proxy_host"`

	// QuotaResetAt DEPRECATED. Use `consumption_period_end` from the getProject endpoint instead.
	// A timestamp indicating when the project quota resets
	// Deprecated:
	QuotaResetAt *time.Time `json:"quota_reset_at,omitempty"`

	// RegionId The region identifier
	RegionId string               `json:"region_id"`
	Settings *ProjectSettingsData `json:"settings,omitempty"`

	// StorePasswords Whether or not passwords are stored for roles in the Neon project. Storing passwords facilitates access to Neon features that require authorization.
	StorePasswords bool `json:"store_passwords"`

	// SyntheticStorageSize Experimental. Do not use this field yet.
	// The data storage size in bytes.
	SyntheticStorageSize *int64 `json:"synthetic_storage_size,omitempty"`

	// UpdatedAt A timestamp indicating when the project was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// ProjectOperations defines model for ProjectOperations.
type ProjectOperations struct {
	Operations []Operation `json:"operations"`
	Project    Project     `json:"project"`
}

// ProjectOwnerData defines model for ProjectOwnerData.
type ProjectOwnerData struct {
	BranchesLimit int    `json:"branches_limit"`
	Email         string `json:"email"`

	// SubscriptionType Type of subscription to Neon Cloud.
	// Notice that for users without billing account this will be "UNKNOWN"
	SubscriptionType BillingSubscriptionType `json:"subscription_type"`
}

// ProjectQuota Per-project consumption quota. If the quota is exceeded, all active computes
// are automatically suspended and it will not be possible to start them with
// an API method call or incoming proxy connections. The only exception is
// `logical_size_bytes`, which is applied on per-branch basis, i.e., only the
// compute on the branch that exceeds the `logical_size` quota will be suspended.
//
// Quotas are enforced based on per-project consumption metrics with the same names,
// which are reset at the end of each billing period (the first day of the month).
// Logical size is also an exception in this case, as it represents the total size
// of data stored in a branch, so it is not reset.
//
// A zero or empty quota value means 'unlimited'.
type ProjectQuota struct {
	// ActiveTimeSeconds The total amount of wall-clock time allowed to be spent by the project's compute endpoints.
	ActiveTimeSeconds *int64 `json:"active_time_seconds,omitempty"`

	// ComputeTimeSeconds The total amount of CPU seconds allowed to be spent by the project's compute endpoints.
	ComputeTimeSeconds *int64 `json:"compute_time_seconds,omitempty"`

	// DataTransferBytes Total amount of data transferred from all of a project's branches using the proxy.
	DataTransferBytes *int64 `json:"data_transfer_bytes,omitempty"`

	// LogicalSizeBytes Limit on the logical size of every project's branch.
	LogicalSizeBytes *int64 `json:"logical_size_bytes,omitempty"`

	// WrittenDataBytes Total amount of data written to all of a project's branches.
	WrittenDataBytes *int64 `json:"written_data_bytes,omitempty"`
}

// ProjectResponse defines model for ProjectResponse.
type ProjectResponse struct {
	Project Project `json:"project"`
}

// ProjectSettingsData defines model for ProjectSettingsData.
type ProjectSettingsData struct {
	// Quota Per-project consumption quota. If the quota is exceeded, all active computes
	// are automatically suspended and it will not be possible to start them with
	// an API method call or incoming proxy connections. The only exception is
	// `logical_size_bytes`, which is applied on per-branch basis, i.e., only the
	// compute on the branch that exceeds the `logical_size` quota will be suspended.
	//
	// Quotas are enforced based on per-project consumption metrics with the same names,
	// which are reset at the end of each billing period (the first day of the month).
	// Logical size is also an exception in this case, as it represents the total size
	// of data stored in a branch, so it is not reset.
	//
	// A zero or empty quota value means 'unlimited'.
	Quota *ProjectQuota `json:"quota,omitempty"`
}

// ProjectUpdateRequest defines model for ProjectUpdateRequest.
type ProjectUpdateRequest struct {
	Project struct {
		// DefaultEndpointSettings A collection of settings for a Neon endpoint
		DefaultEndpointSettings *DefaultEndpointSettings `json:"default_endpoint_settings,omitempty"`

		// HistoryRetentionSeconds The number of seconds to retain the point-in-time restore (PITR) backup history for this project.
		// The default is 604800 seconds (7 days).
		HistoryRetentionSeconds *int64 `json:"history_retention_seconds,omitempty"`

		// Name The project name
		Name     *string              `json:"name,omitempty"`
		Settings *ProjectSettingsData `json:"settings,omitempty"`
	} `json:"project"`
}

// ProjectsResponse defines model for ProjectsResponse.
type ProjectsResponse struct {
	Projects []ProjectListItem `json:"projects"`
}

// Provisioner The Neon compute provisioner. Select the `k8s-neonvm` provisioner to enable autoscaling.
type Provisioner string

// Role defines model for Role.
type Role struct {
	// BranchId The ID of the branch to which the role belongs
	BranchId string `json:"branch_id"`

	// CreatedAt A timestamp indicating when the role was created
	CreatedAt time.Time `json:"created_at"`

	// Name The role name
	Name string `json:"name"`

	// Password The role password
	Password *string `json:"password,omitempty"`

	// Protected Whether or not the role is system-protected
	Protected *bool `json:"protected,omitempty"`

	// UpdatedAt A timestamp indicating when the role was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// RoleCreateRequest defines model for RoleCreateRequest.
type RoleCreateRequest struct {
	Role struct {
		// Name The role name. Cannot exceed 63 bytes in length.
		Name string `json:"name"`
	} `json:"role"`
}

// RoleOperations defines model for RoleOperations.
type RoleOperations struct {
	Operations []Operation `json:"operations"`
	Role       Role        `json:"role"`
}

// RolePasswordResponse defines model for RolePasswordResponse.
type RolePasswordResponse struct {
	// Password The role password
	Password string `json:"password"`
}

// RoleResponse defines model for RoleResponse.
type RoleResponse struct {
	Role Role `json:"role"`
}

// RolesResponse defines model for RolesResponse.
type RolesResponse struct {
	Roles []Role `json:"roles"`
}

// SuspendTimeoutSeconds Duration of inactivity in seconds after which the cimpute endpoint is
// automatically suspended. The value `0` means use the global default.
// The value `-1` means never suspend. The default value is `300` seconds (5 minutes).
// The maximum value is `604800` seconds (1 week). For more information, see
// [Auto-suspend configuration](https://neon.tech/docs/manage/endpoints#auto-suspend-configuration).
type SuspendTimeoutSeconds = int64

// CreatedBranch defines model for CreatedBranch.
type CreatedBranch struct {
	Branch         Branch               `json:"branch"`
	ConnectionUris *[]ConnectionDetails `json:"connection_uris,omitempty"`
	Endpoints      []Endpoint           `json:"endpoints"`
	Operations     []Operation          `json:"operations"`
}

// CreatedProject defines model for CreatedProject.
type CreatedProject struct {
	Branch         Branch              `json:"branch"`
	ConnectionUris []ConnectionDetails `json:"connection_uris"`
	Databases      []Database          `json:"databases"`
	Endpoints      []Endpoint          `json:"endpoints"`
	Operations     []Operation         `json:"operations"`
	Project        Project             `json:"project"`
	Roles          []Role              `json:"roles"`
}

// GeneralErrorResp General Error
type GeneralErrorResp = GeneralError

// ListOperations defines model for ListOperations.
type ListOperations struct {
	Operations []Operation `json:"operations"`

	// Pagination Cursor based pagination is used. The user must pass the cursor as is to the backend.
	// For more information about cursor based pagination, see
	// https://learn.microsoft.com/en-us/ef/core/querying/pagination#keyset-pagination
	Pagination *Pagination `json:"pagination,omitempty"`
}

// ListProjectsParams defines parameters for ListProjects.
type ListProjectsParams struct {
	// Cursor Specify the cursor value from the previous response to get the next batch of projects.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Specify a value from 1 to 100 to limit number of projects in the response.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListProjectOperationsParams defines parameters for ListProjectOperations.
type ListProjectOperationsParams struct {
	// Cursor Specify the cursor value from the previous response to get the next batch of operations
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Specify a value from 1 to 1000 to limit number of operations in the response
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// CreateApiKeyJSONRequestBody defines body for CreateApiKey for application/json ContentType.
type CreateApiKeyJSONRequestBody = ApiKeyCreateRequest

// CreateProjectJSONRequestBody defines body for CreateProject for application/json ContentType.
type CreateProjectJSONRequestBody = ProjectCreateRequest

// UpdateProjectJSONRequestBody defines body for UpdateProject for application/json ContentType.
type UpdateProjectJSONRequestBody = ProjectUpdateRequest

// CreateProjectBranchJSONRequestBody defines body for CreateProjectBranch for application/json ContentType.
type CreateProjectBranchJSONRequestBody = BranchCreateRequest

// UpdateProjectBranchJSONRequestBody defines body for UpdateProjectBranch for application/json ContentType.
type UpdateProjectBranchJSONRequestBody = BranchUpdateRequest

// CreateProjectBranchDatabaseJSONRequestBody defines body for CreateProjectBranchDatabase for application/json ContentType.
type CreateProjectBranchDatabaseJSONRequestBody = DatabaseCreateRequest

// UpdateProjectBranchDatabaseJSONRequestBody defines body for UpdateProjectBranchDatabase for application/json ContentType.
type UpdateProjectBranchDatabaseJSONRequestBody = DatabaseUpdateRequest

// CreateProjectBranchRoleJSONRequestBody defines body for CreateProjectBranchRole for application/json ContentType.
type CreateProjectBranchRoleJSONRequestBody = RoleCreateRequest

// CreateProjectEndpointJSONRequestBody defines body for CreateProjectEndpoint for application/json ContentType.
type CreateProjectEndpointJSONRequestBody = EndpointCreateRequest

// UpdateProjectEndpointJSONRequestBody defines body for UpdateProjectEndpoint for application/json ContentType.
type UpdateProjectEndpointJSONRequestBody = EndpointUpdateRequest

// Getter for additional properties for DefaultEndpointSettings. Returns the specified
// element and whether it was found
func (a DefaultEndpointSettings) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DefaultEndpointSettings
func (a *DefaultEndpointSettings) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DefaultEndpointSettings to handle AdditionalProperties
func (a *DefaultEndpointSettings) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["autoscaling_limit_max_cu"]; found {
		err = json.Unmarshal(raw, &a.AutoscalingLimitMaxCu)
		if err != nil {
			return fmt.Errorf("error reading 'autoscaling_limit_max_cu': %w", err)
		}
		delete(object, "autoscaling_limit_max_cu")
	}

	if raw, found := object["autoscaling_limit_min_cu"]; found {
		err = json.Unmarshal(raw, &a.AutoscalingLimitMinCu)
		if err != nil {
			return fmt.Errorf("error reading 'autoscaling_limit_min_cu': %w", err)
		}
		delete(object, "autoscaling_limit_min_cu")
	}

	if raw, found := object["pg_settings"]; found {
		err = json.Unmarshal(raw, &a.PgSettings)
		if err != nil {
			return fmt.Errorf("error reading 'pg_settings': %w", err)
		}
		delete(object, "pg_settings")
	}

	if raw, found := object["suspend_timeout_seconds"]; found {
		err = json.Unmarshal(raw, &a.SuspendTimeoutSeconds)
		if err != nil {
			return fmt.Errorf("error reading 'suspend_timeout_seconds': %w", err)
		}
		delete(object, "suspend_timeout_seconds")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshalling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DefaultEndpointSettings to handle AdditionalProperties
func (a DefaultEndpointSettings) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AutoscalingLimitMaxCu != nil {
		object["autoscaling_limit_max_cu"], err = json.Marshal(a.AutoscalingLimitMaxCu)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'autoscaling_limit_max_cu': %w", err)
		}
	}

	if a.AutoscalingLimitMinCu != nil {
		object["autoscaling_limit_min_cu"], err = json.Marshal(a.AutoscalingLimitMinCu)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'autoscaling_limit_min_cu': %w", err)
		}
	}

	if a.PgSettings != nil {
		object["pg_settings"], err = json.Marshal(a.PgSettings)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pg_settings': %w", err)
		}
	}

	if a.SuspendTimeoutSeconds != nil {
		object["suspend_timeout_seconds"], err = json.Marshal(a.SuspendTimeoutSeconds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'suspend_timeout_seconds': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListApiKeys request
	ListApiKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateApiKey request with any body
	CreateApiKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApiKey(ctx context.Context, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeApiKey request
	RevokeApiKey(ctx context.Context, keyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjects request
	ListProjects(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProject request with any body
	CreateProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProject(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProject request
	DeleteProject(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProject request
	GetProject(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProject request with any body
	UpdateProjectWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProject(ctx context.Context, projectId string, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectBranches request
	ListProjectBranches(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectBranch request with any body
	CreateProjectBranchWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProjectBranch(ctx context.Context, projectId string, body CreateProjectBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectBranch request
	DeleteProjectBranch(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectBranch request
	GetProjectBranch(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectBranch request with any body
	UpdateProjectBranchWithBody(ctx context.Context, projectId string, branchId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProjectBranch(ctx context.Context, projectId string, branchId string, body UpdateProjectBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectBranchDatabases request
	ListProjectBranchDatabases(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectBranchDatabase request with any body
	CreateProjectBranchDatabaseWithBody(ctx context.Context, projectId string, branchId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProjectBranchDatabase(ctx context.Context, projectId string, branchId string, body CreateProjectBranchDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectBranchDatabase request
	DeleteProjectBranchDatabase(ctx context.Context, projectId string, branchId string, databaseName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectBranchDatabase request
	GetProjectBranchDatabase(ctx context.Context, projectId string, branchId string, databaseName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectBranchDatabase request with any body
	UpdateProjectBranchDatabaseWithBody(ctx context.Context, projectId string, branchId string, databaseName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProjectBranchDatabase(ctx context.Context, projectId string, branchId string, databaseName string, body UpdateProjectBranchDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectBranchEndpoints request
	ListProjectBranchEndpoints(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectBranchRoles request
	ListProjectBranchRoles(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectBranchRole request with any body
	CreateProjectBranchRoleWithBody(ctx context.Context, projectId string, branchId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProjectBranchRole(ctx context.Context, projectId string, branchId string, body CreateProjectBranchRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectBranchRole request
	DeleteProjectBranchRole(ctx context.Context, projectId string, branchId string, roleName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectBranchRole request
	GetProjectBranchRole(ctx context.Context, projectId string, branchId string, roleName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetProjectBranchRolePassword request
	ResetProjectBranchRolePassword(ctx context.Context, projectId string, branchId string, roleName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectBranchRolePassword request
	GetProjectBranchRolePassword(ctx context.Context, projectId string, branchId string, roleName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetPrimaryProjectBranch request
	SetPrimaryProjectBranch(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectEndpoints request
	ListProjectEndpoints(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProjectEndpoint request with any body
	CreateProjectEndpointWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProjectEndpoint(ctx context.Context, projectId string, body CreateProjectEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProjectEndpoint request
	DeleteProjectEndpoint(ctx context.Context, projectId string, endpointId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectEndpoint request
	GetProjectEndpoint(ctx context.Context, projectId string, endpointId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProjectEndpoint request with any body
	UpdateProjectEndpointWithBody(ctx context.Context, projectId string, endpointId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProjectEndpoint(ctx context.Context, projectId string, endpointId string, body UpdateProjectEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartProjectEndpoint request
	StartProjectEndpoint(ctx context.Context, projectId string, endpointId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SuspendProjectEndpoint request
	SuspendProjectEndpoint(ctx context.Context, projectId string, endpointId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjectOperations request
	ListProjectOperations(ctx context.Context, projectId string, params *ListProjectOperationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProjectOperation request
	GetProjectOperation(ctx context.Context, projectId string, operationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListApiKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApiKeysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApiKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApiKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApiKey(ctx context.Context, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApiKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeApiKey(ctx context.Context, keyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeApiKeyRequest(c.Server, keyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjects(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProject(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProject(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProject(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProject(ctx context.Context, projectId string, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectBranches(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectBranchesRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectBranchWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectBranchRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectBranch(ctx context.Context, projectId string, body CreateProjectBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectBranchRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectBranch(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectBranchRequest(c.Server, projectId, branchId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectBranch(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectBranchRequest(c.Server, projectId, branchId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectBranchWithBody(ctx context.Context, projectId string, branchId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectBranchRequestWithBody(c.Server, projectId, branchId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectBranch(ctx context.Context, projectId string, branchId string, body UpdateProjectBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectBranchRequest(c.Server, projectId, branchId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectBranchDatabases(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectBranchDatabasesRequest(c.Server, projectId, branchId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectBranchDatabaseWithBody(ctx context.Context, projectId string, branchId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectBranchDatabaseRequestWithBody(c.Server, projectId, branchId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectBranchDatabase(ctx context.Context, projectId string, branchId string, body CreateProjectBranchDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectBranchDatabaseRequest(c.Server, projectId, branchId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectBranchDatabase(ctx context.Context, projectId string, branchId string, databaseName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectBranchDatabaseRequest(c.Server, projectId, branchId, databaseName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectBranchDatabase(ctx context.Context, projectId string, branchId string, databaseName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectBranchDatabaseRequest(c.Server, projectId, branchId, databaseName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectBranchDatabaseWithBody(ctx context.Context, projectId string, branchId string, databaseName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectBranchDatabaseRequestWithBody(c.Server, projectId, branchId, databaseName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectBranchDatabase(ctx context.Context, projectId string, branchId string, databaseName string, body UpdateProjectBranchDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectBranchDatabaseRequest(c.Server, projectId, branchId, databaseName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectBranchEndpoints(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectBranchEndpointsRequest(c.Server, projectId, branchId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectBranchRoles(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectBranchRolesRequest(c.Server, projectId, branchId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectBranchRoleWithBody(ctx context.Context, projectId string, branchId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectBranchRoleRequestWithBody(c.Server, projectId, branchId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectBranchRole(ctx context.Context, projectId string, branchId string, body CreateProjectBranchRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectBranchRoleRequest(c.Server, projectId, branchId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectBranchRole(ctx context.Context, projectId string, branchId string, roleName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectBranchRoleRequest(c.Server, projectId, branchId, roleName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectBranchRole(ctx context.Context, projectId string, branchId string, roleName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectBranchRoleRequest(c.Server, projectId, branchId, roleName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetProjectBranchRolePassword(ctx context.Context, projectId string, branchId string, roleName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetProjectBranchRolePasswordRequest(c.Server, projectId, branchId, roleName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectBranchRolePassword(ctx context.Context, projectId string, branchId string, roleName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectBranchRolePasswordRequest(c.Server, projectId, branchId, roleName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetPrimaryProjectBranch(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetPrimaryProjectBranchRequest(c.Server, projectId, branchId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectEndpoints(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectEndpointsRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectEndpointWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectEndpointRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProjectEndpoint(ctx context.Context, projectId string, body CreateProjectEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProjectEndpointRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectEndpoint(ctx context.Context, projectId string, endpointId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProjectEndpointRequest(c.Server, projectId, endpointId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectEndpoint(ctx context.Context, projectId string, endpointId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectEndpointRequest(c.Server, projectId, endpointId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectEndpointWithBody(ctx context.Context, projectId string, endpointId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectEndpointRequestWithBody(c.Server, projectId, endpointId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectEndpoint(ctx context.Context, projectId string, endpointId string, body UpdateProjectEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectEndpointRequest(c.Server, projectId, endpointId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartProjectEndpoint(ctx context.Context, projectId string, endpointId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartProjectEndpointRequest(c.Server, projectId, endpointId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SuspendProjectEndpoint(ctx context.Context, projectId string, endpointId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSuspendProjectEndpointRequest(c.Server, projectId, endpointId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjectOperations(ctx context.Context, projectId string, params *ListProjectOperationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectOperationsRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectOperation(ctx context.Context, projectId string, operationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectOperationRequest(c.Server, projectId, operationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListApiKeysRequest generates requests for ListApiKeys
func NewListApiKeysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api_keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateApiKeyRequest calls the generic CreateApiKey builder with application/json body
func NewCreateApiKeyRequest(server string, body CreateApiKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateApiKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateApiKeyRequestWithBody generates requests for CreateApiKey with any type of body
func NewCreateApiKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api_keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevokeApiKeyRequest generates requests for RevokeApiKey
func NewRevokeApiKeyRequest(server string, keyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key_id", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api_keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProjectsRequest generates requests for ListProjects
func NewListProjectsRequest(server string, params *ListProjectsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectRequest calls the generic CreateProject builder with application/json body
func NewCreateProjectRequest(server string, body CreateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateProjectRequestWithBody generates requests for CreateProject with any type of body
func NewCreateProjectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectRequest generates requests for DeleteProject
func NewDeleteProjectRequest(server string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectRequest generates requests for GetProject
func NewGetProjectRequest(server string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectRequest calls the generic UpdateProject builder with application/json body
func NewUpdateProjectRequest(server string, projectId string, body UpdateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewUpdateProjectRequestWithBody generates requests for UpdateProject with any type of body
func NewUpdateProjectRequestWithBody(server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProjectBranchesRequest generates requests for ListProjectBranches
func NewListProjectBranchesRequest(server string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectBranchRequest calls the generic CreateProjectBranch builder with application/json body
func NewCreateProjectBranchRequest(server string, projectId string, body CreateProjectBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectBranchRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewCreateProjectBranchRequestWithBody generates requests for CreateProjectBranch with any type of body
func NewCreateProjectBranchRequestWithBody(server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectBranchRequest generates requests for DeleteProjectBranch
func NewDeleteProjectBranchRequest(server string, projectId string, branchId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch_id", runtime.ParamLocationPath, branchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectBranchRequest generates requests for GetProjectBranch
func NewGetProjectBranchRequest(server string, projectId string, branchId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch_id", runtime.ParamLocationPath, branchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectBranchRequest calls the generic UpdateProjectBranch builder with application/json body
func NewUpdateProjectBranchRequest(server string, projectId string, branchId string, body UpdateProjectBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectBranchRequestWithBody(server, projectId, branchId, "application/json", bodyReader)
}

// NewUpdateProjectBranchRequestWithBody generates requests for UpdateProjectBranch with any type of body
func NewUpdateProjectBranchRequestWithBody(server string, projectId string, branchId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch_id", runtime.ParamLocationPath, branchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProjectBranchDatabasesRequest generates requests for ListProjectBranchDatabases
func NewListProjectBranchDatabasesRequest(server string, projectId string, branchId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch_id", runtime.ParamLocationPath, branchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/databases", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectBranchDatabaseRequest calls the generic CreateProjectBranchDatabase builder with application/json body
func NewCreateProjectBranchDatabaseRequest(server string, projectId string, branchId string, body CreateProjectBranchDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectBranchDatabaseRequestWithBody(server, projectId, branchId, "application/json", bodyReader)
}

// NewCreateProjectBranchDatabaseRequestWithBody generates requests for CreateProjectBranchDatabase with any type of body
func NewCreateProjectBranchDatabaseRequestWithBody(server string, projectId string, branchId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch_id", runtime.ParamLocationPath, branchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/databases", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectBranchDatabaseRequest generates requests for DeleteProjectBranchDatabase
func NewDeleteProjectBranchDatabaseRequest(server string, projectId string, branchId string, databaseName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch_id", runtime.ParamLocationPath, branchId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "database_name", runtime.ParamLocationPath, databaseName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/databases/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectBranchDatabaseRequest generates requests for GetProjectBranchDatabase
func NewGetProjectBranchDatabaseRequest(server string, projectId string, branchId string, databaseName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch_id", runtime.ParamLocationPath, branchId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "database_name", runtime.ParamLocationPath, databaseName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/databases/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectBranchDatabaseRequest calls the generic UpdateProjectBranchDatabase builder with application/json body
func NewUpdateProjectBranchDatabaseRequest(server string, projectId string, branchId string, databaseName string, body UpdateProjectBranchDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectBranchDatabaseRequestWithBody(server, projectId, branchId, databaseName, "application/json", bodyReader)
}

// NewUpdateProjectBranchDatabaseRequestWithBody generates requests for UpdateProjectBranchDatabase with any type of body
func NewUpdateProjectBranchDatabaseRequestWithBody(server string, projectId string, branchId string, databaseName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch_id", runtime.ParamLocationPath, branchId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "database_name", runtime.ParamLocationPath, databaseName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/databases/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProjectBranchEndpointsRequest generates requests for ListProjectBranchEndpoints
func NewListProjectBranchEndpointsRequest(server string, projectId string, branchId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch_id", runtime.ParamLocationPath, branchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/endpoints", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProjectBranchRolesRequest generates requests for ListProjectBranchRoles
func NewListProjectBranchRolesRequest(server string, projectId string, branchId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch_id", runtime.ParamLocationPath, branchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/roles", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectBranchRoleRequest calls the generic CreateProjectBranchRole builder with application/json body
func NewCreateProjectBranchRoleRequest(server string, projectId string, branchId string, body CreateProjectBranchRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectBranchRoleRequestWithBody(server, projectId, branchId, "application/json", bodyReader)
}

// NewCreateProjectBranchRoleRequestWithBody generates requests for CreateProjectBranchRole with any type of body
func NewCreateProjectBranchRoleRequestWithBody(server string, projectId string, branchId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch_id", runtime.ParamLocationPath, branchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/roles", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectBranchRoleRequest generates requests for DeleteProjectBranchRole
func NewDeleteProjectBranchRoleRequest(server string, projectId string, branchId string, roleName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch_id", runtime.ParamLocationPath, branchId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "role_name", runtime.ParamLocationPath, roleName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/roles/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectBranchRoleRequest generates requests for GetProjectBranchRole
func NewGetProjectBranchRoleRequest(server string, projectId string, branchId string, roleName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch_id", runtime.ParamLocationPath, branchId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "role_name", runtime.ParamLocationPath, roleName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/roles/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetProjectBranchRolePasswordRequest generates requests for ResetProjectBranchRolePassword
func NewResetProjectBranchRolePasswordRequest(server string, projectId string, branchId string, roleName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch_id", runtime.ParamLocationPath, branchId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "role_name", runtime.ParamLocationPath, roleName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/roles/%s/reset_password", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectBranchRolePasswordRequest generates requests for GetProjectBranchRolePassword
func NewGetProjectBranchRolePasswordRequest(server string, projectId string, branchId string, roleName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch_id", runtime.ParamLocationPath, branchId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "role_name", runtime.ParamLocationPath, roleName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/roles/%s/reveal_password", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetPrimaryProjectBranchRequest generates requests for SetPrimaryProjectBranch
func NewSetPrimaryProjectBranchRequest(server string, projectId string, branchId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch_id", runtime.ParamLocationPath, branchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/branches/%s/set_as_primary", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProjectEndpointsRequest generates requests for ListProjectEndpoints
func NewListProjectEndpointsRequest(server string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/endpoints", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProjectEndpointRequest calls the generic CreateProjectEndpoint builder with application/json body
func NewCreateProjectEndpointRequest(server string, projectId string, body CreateProjectEndpointJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProjectEndpointRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewCreateProjectEndpointRequestWithBody generates requests for CreateProjectEndpoint with any type of body
func NewCreateProjectEndpointRequestWithBody(server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/endpoints", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProjectEndpointRequest generates requests for DeleteProjectEndpoint
func NewDeleteProjectEndpointRequest(server string, projectId string, endpointId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "endpoint_id", runtime.ParamLocationPath, endpointId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/endpoints/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectEndpointRequest generates requests for GetProjectEndpoint
func NewGetProjectEndpointRequest(server string, projectId string, endpointId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "endpoint_id", runtime.ParamLocationPath, endpointId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/endpoints/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectEndpointRequest calls the generic UpdateProjectEndpoint builder with application/json body
func NewUpdateProjectEndpointRequest(server string, projectId string, endpointId string, body UpdateProjectEndpointJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectEndpointRequestWithBody(server, projectId, endpointId, "application/json", bodyReader)
}

// NewUpdateProjectEndpointRequestWithBody generates requests for UpdateProjectEndpoint with any type of body
func NewUpdateProjectEndpointRequestWithBody(server string, projectId string, endpointId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "endpoint_id", runtime.ParamLocationPath, endpointId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/endpoints/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStartProjectEndpointRequest generates requests for StartProjectEndpoint
func NewStartProjectEndpointRequest(server string, projectId string, endpointId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "endpoint_id", runtime.ParamLocationPath, endpointId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/endpoints/%s/start", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSuspendProjectEndpointRequest generates requests for SuspendProjectEndpoint
func NewSuspendProjectEndpointRequest(server string, projectId string, endpointId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "endpoint_id", runtime.ParamLocationPath, endpointId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/endpoints/%s/suspend", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProjectOperationsRequest generates requests for ListProjectOperations
func NewListProjectOperationsRequest(server string, projectId string, params *ListProjectOperationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/operations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectOperationRequest generates requests for GetProjectOperation
func NewGetProjectOperationRequest(server string, projectId string, operationId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "operation_id", runtime.ParamLocationPath, operationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/operations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListApiKeys request
	ListApiKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListApiKeysResponse, error)

	// CreateApiKey request with any body
	CreateApiKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApiKeyResponse, error)

	CreateApiKeyWithResponse(ctx context.Context, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApiKeyResponse, error)

	// RevokeApiKey request
	RevokeApiKeyWithResponse(ctx context.Context, keyId int64, reqEditors ...RequestEditorFn) (*RevokeApiKeyResponse, error)

	// ListProjects request
	ListProjectsWithResponse(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*ListProjectsResponse, error)

	// CreateProject request with any body
	CreateProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error)

	CreateProjectWithResponse(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error)

	// DeleteProject request
	DeleteProjectWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*DeleteProjectResponse, error)

	// GetProject request
	GetProjectWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*GetProjectResponse, error)

	// UpdateProject request with any body
	UpdateProjectWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error)

	UpdateProjectWithResponse(ctx context.Context, projectId string, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error)

	// ListProjectBranches request
	ListProjectBranchesWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*ListProjectBranchesResponse, error)

	// CreateProjectBranch request with any body
	CreateProjectBranchWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectBranchResponse, error)

	CreateProjectBranchWithResponse(ctx context.Context, projectId string, body CreateProjectBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectBranchResponse, error)

	// DeleteProjectBranch request
	DeleteProjectBranchWithResponse(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*DeleteProjectBranchResponse, error)

	// GetProjectBranch request
	GetProjectBranchWithResponse(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*GetProjectBranchResponse, error)

	// UpdateProjectBranch request with any body
	UpdateProjectBranchWithBodyWithResponse(ctx context.Context, projectId string, branchId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectBranchResponse, error)

	UpdateProjectBranchWithResponse(ctx context.Context, projectId string, branchId string, body UpdateProjectBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectBranchResponse, error)

	// ListProjectBranchDatabases request
	ListProjectBranchDatabasesWithResponse(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*ListProjectBranchDatabasesResponse, error)

	// CreateProjectBranchDatabase request with any body
	CreateProjectBranchDatabaseWithBodyWithResponse(ctx context.Context, projectId string, branchId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectBranchDatabaseResponse, error)

	CreateProjectBranchDatabaseWithResponse(ctx context.Context, projectId string, branchId string, body CreateProjectBranchDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectBranchDatabaseResponse, error)

	// DeleteProjectBranchDatabase request
	DeleteProjectBranchDatabaseWithResponse(ctx context.Context, projectId string, branchId string, databaseName string, reqEditors ...RequestEditorFn) (*DeleteProjectBranchDatabaseResponse, error)

	// GetProjectBranchDatabase request
	GetProjectBranchDatabaseWithResponse(ctx context.Context, projectId string, branchId string, databaseName string, reqEditors ...RequestEditorFn) (*GetProjectBranchDatabaseResponse, error)

	// UpdateProjectBranchDatabase request with any body
	UpdateProjectBranchDatabaseWithBodyWithResponse(ctx context.Context, projectId string, branchId string, databaseName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectBranchDatabaseResponse, error)

	UpdateProjectBranchDatabaseWithResponse(ctx context.Context, projectId string, branchId string, databaseName string, body UpdateProjectBranchDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectBranchDatabaseResponse, error)

	// ListProjectBranchEndpoints request
	ListProjectBranchEndpointsWithResponse(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*ListProjectBranchEndpointsResponse, error)

	// ListProjectBranchRoles request
	ListProjectBranchRolesWithResponse(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*ListProjectBranchRolesResponse, error)

	// CreateProjectBranchRole request with any body
	CreateProjectBranchRoleWithBodyWithResponse(ctx context.Context, projectId string, branchId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectBranchRoleResponse, error)

	CreateProjectBranchRoleWithResponse(ctx context.Context, projectId string, branchId string, body CreateProjectBranchRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectBranchRoleResponse, error)

	// DeleteProjectBranchRole request
	DeleteProjectBranchRoleWithResponse(ctx context.Context, projectId string, branchId string, roleName string, reqEditors ...RequestEditorFn) (*DeleteProjectBranchRoleResponse, error)

	// GetProjectBranchRole request
	GetProjectBranchRoleWithResponse(ctx context.Context, projectId string, branchId string, roleName string, reqEditors ...RequestEditorFn) (*GetProjectBranchRoleResponse, error)

	// ResetProjectBranchRolePassword request
	ResetProjectBranchRolePasswordWithResponse(ctx context.Context, projectId string, branchId string, roleName string, reqEditors ...RequestEditorFn) (*ResetProjectBranchRolePasswordResponse, error)

	// GetProjectBranchRolePassword request
	GetProjectBranchRolePasswordWithResponse(ctx context.Context, projectId string, branchId string, roleName string, reqEditors ...RequestEditorFn) (*GetProjectBranchRolePasswordResponse, error)

	// SetPrimaryProjectBranch request
	SetPrimaryProjectBranchWithResponse(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*SetPrimaryProjectBranchResponse, error)

	// ListProjectEndpoints request
	ListProjectEndpointsWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*ListProjectEndpointsResponse, error)

	// CreateProjectEndpoint request with any body
	CreateProjectEndpointWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectEndpointResponse, error)

	CreateProjectEndpointWithResponse(ctx context.Context, projectId string, body CreateProjectEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectEndpointResponse, error)

	// DeleteProjectEndpoint request
	DeleteProjectEndpointWithResponse(ctx context.Context, projectId string, endpointId string, reqEditors ...RequestEditorFn) (*DeleteProjectEndpointResponse, error)

	// GetProjectEndpoint request
	GetProjectEndpointWithResponse(ctx context.Context, projectId string, endpointId string, reqEditors ...RequestEditorFn) (*GetProjectEndpointResponse, error)

	// UpdateProjectEndpoint request with any body
	UpdateProjectEndpointWithBodyWithResponse(ctx context.Context, projectId string, endpointId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectEndpointResponse, error)

	UpdateProjectEndpointWithResponse(ctx context.Context, projectId string, endpointId string, body UpdateProjectEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectEndpointResponse, error)

	// StartProjectEndpoint request
	StartProjectEndpointWithResponse(ctx context.Context, projectId string, endpointId string, reqEditors ...RequestEditorFn) (*StartProjectEndpointResponse, error)

	// SuspendProjectEndpoint request
	SuspendProjectEndpointWithResponse(ctx context.Context, projectId string, endpointId string, reqEditors ...RequestEditorFn) (*SuspendProjectEndpointResponse, error)

	// ListProjectOperations request
	ListProjectOperationsWithResponse(ctx context.Context, projectId string, params *ListProjectOperationsParams, reqEditors ...RequestEditorFn) (*ListProjectOperationsResponse, error)

	// GetProjectOperation request
	GetProjectOperationWithResponse(ctx context.Context, projectId string, operationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetProjectOperationResponse, error)
}

type ListApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ApiKeysListResponseItem
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r ListApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateApiKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiKeyCreateResponse
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r CreateApiKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateApiKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeApiKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiKeyRevokeResponse
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r RevokeApiKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeApiKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Pagination Cursor based pagination is used. The user must pass the cursor as is to the backend.
		// For more information about cursor based pagination, see
		// https://learn.microsoft.com/en-us/ef/core/querying/pagination#keyset-pagination
		Pagination *Pagination       `json:"pagination,omitempty"`
		Projects   []ProjectListItem `json:"projects"`
	}
	JSONDefault *GeneralError
}

// Status returns HTTPResponse.Status
func (r ListProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Branch         Branch              `json:"branch"`
		ConnectionUris []ConnectionDetails `json:"connection_uris"`
		Databases      []Database          `json:"databases"`
		Endpoints      []Endpoint          `json:"endpoints"`
		Operations     []Operation         `json:"operations"`
		Project        Project             `json:"project"`
		Roles          []Role              `json:"roles"`
	}
	JSONDefault *GeneralError
}

// Status returns HTTPResponse.Status
func (r CreateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectResponse
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r DeleteProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectResponse
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r GetProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectOperations
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r UpdateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectBranchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BranchesResponse
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r ListProjectBranchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectBranchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Branch         Branch               `json:"branch"`
		ConnectionUris *[]ConnectionDetails `json:"connection_uris,omitempty"`
		Endpoints      []Endpoint           `json:"endpoints"`
		Operations     []Operation          `json:"operations"`
	}
	JSONDefault *GeneralError
}

// Status returns HTTPResponse.Status
func (r CreateProjectBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BranchOperations
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r DeleteProjectBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BranchResponse
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r GetProjectBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BranchOperations
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r UpdateProjectBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectBranchDatabasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DatabasesResponse
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r ListProjectBranchDatabasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectBranchDatabasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectBranchDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DatabaseOperations
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r CreateProjectBranchDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectBranchDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectBranchDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DatabaseOperations
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r DeleteProjectBranchDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectBranchDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectBranchDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DatabaseResponse
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r GetProjectBranchDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectBranchDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectBranchDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DatabaseOperations
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r UpdateProjectBranchDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectBranchDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectBranchEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointsResponse
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r ListProjectBranchEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectBranchEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectBranchRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RolesResponse
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r ListProjectBranchRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectBranchRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectBranchRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RoleOperations
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r CreateProjectBranchRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectBranchRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectBranchRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RoleOperations
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r DeleteProjectBranchRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectBranchRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectBranchRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RoleResponse
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r GetProjectBranchRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectBranchRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetProjectBranchRolePasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RoleOperations
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r ResetProjectBranchRolePasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetProjectBranchRolePasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectBranchRolePasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RolePasswordResponse
	JSON404      *GeneralError
	JSON412      *GeneralError
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r GetProjectBranchRolePasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectBranchRolePasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetPrimaryProjectBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BranchOperations
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r SetPrimaryProjectBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetPrimaryProjectBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointsResponse
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r ListProjectEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProjectEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EndpointOperations
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r CreateProjectEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProjectEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointOperations
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r DeleteProjectEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointResponse
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r GetProjectEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointOperations
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r UpdateProjectEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartProjectEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointOperations
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r StartProjectEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartProjectEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SuspendProjectEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndpointOperations
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r SuspendProjectEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SuspendProjectEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectOperationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Operations []Operation `json:"operations"`

		// Pagination Cursor based pagination is used. The user must pass the cursor as is to the backend.
		// For more information about cursor based pagination, see
		// https://learn.microsoft.com/en-us/ef/core/querying/pagination#keyset-pagination
		Pagination *Pagination `json:"pagination,omitempty"`
	}
	JSONDefault *GeneralError
}

// Status returns HTTPResponse.Status
func (r ListProjectOperationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectOperationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectOperationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OperationResponse
	JSONDefault  *GeneralError
}

// Status returns HTTPResponse.Status
func (r GetProjectOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListApiKeysWithResponse request returning *ListApiKeysResponse
func (c *ClientWithResponses) ListApiKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListApiKeysResponse, error) {
	rsp, err := c.ListApiKeys(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApiKeysResponse(rsp)
}

// CreateApiKeyWithBodyWithResponse request with arbitrary body returning *CreateApiKeyResponse
func (c *ClientWithResponses) CreateApiKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApiKeyResponse, error) {
	rsp, err := c.CreateApiKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApiKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateApiKeyWithResponse(ctx context.Context, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApiKeyResponse, error) {
	rsp, err := c.CreateApiKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApiKeyResponse(rsp)
}

// RevokeApiKeyWithResponse request returning *RevokeApiKeyResponse
func (c *ClientWithResponses) RevokeApiKeyWithResponse(ctx context.Context, keyId int64, reqEditors ...RequestEditorFn) (*RevokeApiKeyResponse, error) {
	rsp, err := c.RevokeApiKey(ctx, keyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeApiKeyResponse(rsp)
}

// ListProjectsWithResponse request returning *ListProjectsResponse
func (c *ClientWithResponses) ListProjectsWithResponse(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*ListProjectsResponse, error) {
	rsp, err := c.ListProjects(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectsResponse(rsp)
}

// CreateProjectWithBodyWithResponse request with arbitrary body returning *CreateProjectResponse
func (c *ClientWithResponses) CreateProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error) {
	rsp, err := c.CreateProjectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectWithResponse(ctx context.Context, body CreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectResponse, error) {
	rsp, err := c.CreateProject(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectResponse(rsp)
}

// DeleteProjectWithResponse request returning *DeleteProjectResponse
func (c *ClientWithResponses) DeleteProjectWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*DeleteProjectResponse, error) {
	rsp, err := c.DeleteProject(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectResponse(rsp)
}

// GetProjectWithResponse request returning *GetProjectResponse
func (c *ClientWithResponses) GetProjectWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*GetProjectResponse, error) {
	rsp, err := c.GetProject(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectResponse(rsp)
}

// UpdateProjectWithBodyWithResponse request with arbitrary body returning *UpdateProjectResponse
func (c *ClientWithResponses) UpdateProjectWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error) {
	rsp, err := c.UpdateProjectWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectWithResponse(ctx context.Context, projectId string, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error) {
	rsp, err := c.UpdateProject(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectResponse(rsp)
}

// ListProjectBranchesWithResponse request returning *ListProjectBranchesResponse
func (c *ClientWithResponses) ListProjectBranchesWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*ListProjectBranchesResponse, error) {
	rsp, err := c.ListProjectBranches(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectBranchesResponse(rsp)
}

// CreateProjectBranchWithBodyWithResponse request with arbitrary body returning *CreateProjectBranchResponse
func (c *ClientWithResponses) CreateProjectBranchWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectBranchResponse, error) {
	rsp, err := c.CreateProjectBranchWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectBranchResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectBranchWithResponse(ctx context.Context, projectId string, body CreateProjectBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectBranchResponse, error) {
	rsp, err := c.CreateProjectBranch(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectBranchResponse(rsp)
}

// DeleteProjectBranchWithResponse request returning *DeleteProjectBranchResponse
func (c *ClientWithResponses) DeleteProjectBranchWithResponse(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*DeleteProjectBranchResponse, error) {
	rsp, err := c.DeleteProjectBranch(ctx, projectId, branchId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectBranchResponse(rsp)
}

// GetProjectBranchWithResponse request returning *GetProjectBranchResponse
func (c *ClientWithResponses) GetProjectBranchWithResponse(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*GetProjectBranchResponse, error) {
	rsp, err := c.GetProjectBranch(ctx, projectId, branchId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectBranchResponse(rsp)
}

// UpdateProjectBranchWithBodyWithResponse request with arbitrary body returning *UpdateProjectBranchResponse
func (c *ClientWithResponses) UpdateProjectBranchWithBodyWithResponse(ctx context.Context, projectId string, branchId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectBranchResponse, error) {
	rsp, err := c.UpdateProjectBranchWithBody(ctx, projectId, branchId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectBranchResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectBranchWithResponse(ctx context.Context, projectId string, branchId string, body UpdateProjectBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectBranchResponse, error) {
	rsp, err := c.UpdateProjectBranch(ctx, projectId, branchId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectBranchResponse(rsp)
}

// ListProjectBranchDatabasesWithResponse request returning *ListProjectBranchDatabasesResponse
func (c *ClientWithResponses) ListProjectBranchDatabasesWithResponse(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*ListProjectBranchDatabasesResponse, error) {
	rsp, err := c.ListProjectBranchDatabases(ctx, projectId, branchId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectBranchDatabasesResponse(rsp)
}

// CreateProjectBranchDatabaseWithBodyWithResponse request with arbitrary body returning *CreateProjectBranchDatabaseResponse
func (c *ClientWithResponses) CreateProjectBranchDatabaseWithBodyWithResponse(ctx context.Context, projectId string, branchId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectBranchDatabaseResponse, error) {
	rsp, err := c.CreateProjectBranchDatabaseWithBody(ctx, projectId, branchId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectBranchDatabaseResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectBranchDatabaseWithResponse(ctx context.Context, projectId string, branchId string, body CreateProjectBranchDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectBranchDatabaseResponse, error) {
	rsp, err := c.CreateProjectBranchDatabase(ctx, projectId, branchId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectBranchDatabaseResponse(rsp)
}

// DeleteProjectBranchDatabaseWithResponse request returning *DeleteProjectBranchDatabaseResponse
func (c *ClientWithResponses) DeleteProjectBranchDatabaseWithResponse(ctx context.Context, projectId string, branchId string, databaseName string, reqEditors ...RequestEditorFn) (*DeleteProjectBranchDatabaseResponse, error) {
	rsp, err := c.DeleteProjectBranchDatabase(ctx, projectId, branchId, databaseName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectBranchDatabaseResponse(rsp)
}

// GetProjectBranchDatabaseWithResponse request returning *GetProjectBranchDatabaseResponse
func (c *ClientWithResponses) GetProjectBranchDatabaseWithResponse(ctx context.Context, projectId string, branchId string, databaseName string, reqEditors ...RequestEditorFn) (*GetProjectBranchDatabaseResponse, error) {
	rsp, err := c.GetProjectBranchDatabase(ctx, projectId, branchId, databaseName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectBranchDatabaseResponse(rsp)
}

// UpdateProjectBranchDatabaseWithBodyWithResponse request with arbitrary body returning *UpdateProjectBranchDatabaseResponse
func (c *ClientWithResponses) UpdateProjectBranchDatabaseWithBodyWithResponse(ctx context.Context, projectId string, branchId string, databaseName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectBranchDatabaseResponse, error) {
	rsp, err := c.UpdateProjectBranchDatabaseWithBody(ctx, projectId, branchId, databaseName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectBranchDatabaseResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectBranchDatabaseWithResponse(ctx context.Context, projectId string, branchId string, databaseName string, body UpdateProjectBranchDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectBranchDatabaseResponse, error) {
	rsp, err := c.UpdateProjectBranchDatabase(ctx, projectId, branchId, databaseName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectBranchDatabaseResponse(rsp)
}

// ListProjectBranchEndpointsWithResponse request returning *ListProjectBranchEndpointsResponse
func (c *ClientWithResponses) ListProjectBranchEndpointsWithResponse(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*ListProjectBranchEndpointsResponse, error) {
	rsp, err := c.ListProjectBranchEndpoints(ctx, projectId, branchId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectBranchEndpointsResponse(rsp)
}

// ListProjectBranchRolesWithResponse request returning *ListProjectBranchRolesResponse
func (c *ClientWithResponses) ListProjectBranchRolesWithResponse(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*ListProjectBranchRolesResponse, error) {
	rsp, err := c.ListProjectBranchRoles(ctx, projectId, branchId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectBranchRolesResponse(rsp)
}

// CreateProjectBranchRoleWithBodyWithResponse request with arbitrary body returning *CreateProjectBranchRoleResponse
func (c *ClientWithResponses) CreateProjectBranchRoleWithBodyWithResponse(ctx context.Context, projectId string, branchId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectBranchRoleResponse, error) {
	rsp, err := c.CreateProjectBranchRoleWithBody(ctx, projectId, branchId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectBranchRoleResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectBranchRoleWithResponse(ctx context.Context, projectId string, branchId string, body CreateProjectBranchRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectBranchRoleResponse, error) {
	rsp, err := c.CreateProjectBranchRole(ctx, projectId, branchId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectBranchRoleResponse(rsp)
}

// DeleteProjectBranchRoleWithResponse request returning *DeleteProjectBranchRoleResponse
func (c *ClientWithResponses) DeleteProjectBranchRoleWithResponse(ctx context.Context, projectId string, branchId string, roleName string, reqEditors ...RequestEditorFn) (*DeleteProjectBranchRoleResponse, error) {
	rsp, err := c.DeleteProjectBranchRole(ctx, projectId, branchId, roleName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectBranchRoleResponse(rsp)
}

// GetProjectBranchRoleWithResponse request returning *GetProjectBranchRoleResponse
func (c *ClientWithResponses) GetProjectBranchRoleWithResponse(ctx context.Context, projectId string, branchId string, roleName string, reqEditors ...RequestEditorFn) (*GetProjectBranchRoleResponse, error) {
	rsp, err := c.GetProjectBranchRole(ctx, projectId, branchId, roleName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectBranchRoleResponse(rsp)
}

// ResetProjectBranchRolePasswordWithResponse request returning *ResetProjectBranchRolePasswordResponse
func (c *ClientWithResponses) ResetProjectBranchRolePasswordWithResponse(ctx context.Context, projectId string, branchId string, roleName string, reqEditors ...RequestEditorFn) (*ResetProjectBranchRolePasswordResponse, error) {
	rsp, err := c.ResetProjectBranchRolePassword(ctx, projectId, branchId, roleName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetProjectBranchRolePasswordResponse(rsp)
}

// GetProjectBranchRolePasswordWithResponse request returning *GetProjectBranchRolePasswordResponse
func (c *ClientWithResponses) GetProjectBranchRolePasswordWithResponse(ctx context.Context, projectId string, branchId string, roleName string, reqEditors ...RequestEditorFn) (*GetProjectBranchRolePasswordResponse, error) {
	rsp, err := c.GetProjectBranchRolePassword(ctx, projectId, branchId, roleName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectBranchRolePasswordResponse(rsp)
}

// SetPrimaryProjectBranchWithResponse request returning *SetPrimaryProjectBranchResponse
func (c *ClientWithResponses) SetPrimaryProjectBranchWithResponse(ctx context.Context, projectId string, branchId string, reqEditors ...RequestEditorFn) (*SetPrimaryProjectBranchResponse, error) {
	rsp, err := c.SetPrimaryProjectBranch(ctx, projectId, branchId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetPrimaryProjectBranchResponse(rsp)
}

// ListProjectEndpointsWithResponse request returning *ListProjectEndpointsResponse
func (c *ClientWithResponses) ListProjectEndpointsWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*ListProjectEndpointsResponse, error) {
	rsp, err := c.ListProjectEndpoints(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectEndpointsResponse(rsp)
}

// CreateProjectEndpointWithBodyWithResponse request with arbitrary body returning *CreateProjectEndpointResponse
func (c *ClientWithResponses) CreateProjectEndpointWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProjectEndpointResponse, error) {
	rsp, err := c.CreateProjectEndpointWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectEndpointResponse(rsp)
}

func (c *ClientWithResponses) CreateProjectEndpointWithResponse(ctx context.Context, projectId string, body CreateProjectEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProjectEndpointResponse, error) {
	rsp, err := c.CreateProjectEndpoint(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProjectEndpointResponse(rsp)
}

// DeleteProjectEndpointWithResponse request returning *DeleteProjectEndpointResponse
func (c *ClientWithResponses) DeleteProjectEndpointWithResponse(ctx context.Context, projectId string, endpointId string, reqEditors ...RequestEditorFn) (*DeleteProjectEndpointResponse, error) {
	rsp, err := c.DeleteProjectEndpoint(ctx, projectId, endpointId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectEndpointResponse(rsp)
}

// GetProjectEndpointWithResponse request returning *GetProjectEndpointResponse
func (c *ClientWithResponses) GetProjectEndpointWithResponse(ctx context.Context, projectId string, endpointId string, reqEditors ...RequestEditorFn) (*GetProjectEndpointResponse, error) {
	rsp, err := c.GetProjectEndpoint(ctx, projectId, endpointId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectEndpointResponse(rsp)
}

// UpdateProjectEndpointWithBodyWithResponse request with arbitrary body returning *UpdateProjectEndpointResponse
func (c *ClientWithResponses) UpdateProjectEndpointWithBodyWithResponse(ctx context.Context, projectId string, endpointId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectEndpointResponse, error) {
	rsp, err := c.UpdateProjectEndpointWithBody(ctx, projectId, endpointId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectEndpointResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectEndpointWithResponse(ctx context.Context, projectId string, endpointId string, body UpdateProjectEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectEndpointResponse, error) {
	rsp, err := c.UpdateProjectEndpoint(ctx, projectId, endpointId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectEndpointResponse(rsp)
}

// StartProjectEndpointWithResponse request returning *StartProjectEndpointResponse
func (c *ClientWithResponses) StartProjectEndpointWithResponse(ctx context.Context, projectId string, endpointId string, reqEditors ...RequestEditorFn) (*StartProjectEndpointResponse, error) {
	rsp, err := c.StartProjectEndpoint(ctx, projectId, endpointId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartProjectEndpointResponse(rsp)
}

// SuspendProjectEndpointWithResponse request returning *SuspendProjectEndpointResponse
func (c *ClientWithResponses) SuspendProjectEndpointWithResponse(ctx context.Context, projectId string, endpointId string, reqEditors ...RequestEditorFn) (*SuspendProjectEndpointResponse, error) {
	rsp, err := c.SuspendProjectEndpoint(ctx, projectId, endpointId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSuspendProjectEndpointResponse(rsp)
}

// ListProjectOperationsWithResponse request returning *ListProjectOperationsResponse
func (c *ClientWithResponses) ListProjectOperationsWithResponse(ctx context.Context, projectId string, params *ListProjectOperationsParams, reqEditors ...RequestEditorFn) (*ListProjectOperationsResponse, error) {
	rsp, err := c.ListProjectOperations(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectOperationsResponse(rsp)
}

// GetProjectOperationWithResponse request returning *GetProjectOperationResponse
func (c *ClientWithResponses) GetProjectOperationWithResponse(ctx context.Context, projectId string, operationId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetProjectOperationResponse, error) {
	rsp, err := c.GetProjectOperation(ctx, projectId, operationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectOperationResponse(rsp)
}

// ParseListApiKeysResponse parses an HTTP response from a ListApiKeysWithResponse call
func ParseListApiKeysResponse(rsp *http.Response) (*ListApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ApiKeysListResponseItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateApiKeyResponse parses an HTTP response from a CreateApiKeyWithResponse call
func ParseCreateApiKeyResponse(rsp *http.Response) (*CreateApiKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateApiKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiKeyCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRevokeApiKeyResponse parses an HTTP response from a RevokeApiKeyWithResponse call
func ParseRevokeApiKeyResponse(rsp *http.Response) (*RevokeApiKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeApiKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiKeyRevokeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListProjectsResponse parses an HTTP response from a ListProjectsWithResponse call
func ParseListProjectsResponse(rsp *http.Response) (*ListProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Pagination Cursor based pagination is used. The user must pass the cursor as is to the backend.
			// For more information about cursor based pagination, see
			// https://learn.microsoft.com/en-us/ef/core/querying/pagination#keyset-pagination
			Pagination *Pagination       `json:"pagination,omitempty"`
			Projects   []ProjectListItem `json:"projects"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateProjectResponse parses an HTTP response from a CreateProjectWithResponse call
func ParseCreateProjectResponse(rsp *http.Response) (*CreateProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Branch         Branch              `json:"branch"`
			ConnectionUris []ConnectionDetails `json:"connection_uris"`
			Databases      []Database          `json:"databases"`
			Endpoints      []Endpoint          `json:"endpoints"`
			Operations     []Operation         `json:"operations"`
			Project        Project             `json:"project"`
			Roles          []Role              `json:"roles"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteProjectResponse parses an HTTP response from a DeleteProjectWithResponse call
func ParseDeleteProjectResponse(rsp *http.Response) (*DeleteProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProjectResponse parses an HTTP response from a GetProjectWithResponse call
func ParseGetProjectResponse(rsp *http.Response) (*GetProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateProjectResponse parses an HTTP response from a UpdateProjectWithResponse call
func ParseUpdateProjectResponse(rsp *http.Response) (*UpdateProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectOperations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListProjectBranchesResponse parses an HTTP response from a ListProjectBranchesWithResponse call
func ParseListProjectBranchesResponse(rsp *http.Response) (*ListProjectBranchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectBranchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BranchesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateProjectBranchResponse parses an HTTP response from a CreateProjectBranchWithResponse call
func ParseCreateProjectBranchResponse(rsp *http.Response) (*CreateProjectBranchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Branch         Branch               `json:"branch"`
			ConnectionUris *[]ConnectionDetails `json:"connection_uris,omitempty"`
			Endpoints      []Endpoint           `json:"endpoints"`
			Operations     []Operation          `json:"operations"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteProjectBranchResponse parses an HTTP response from a DeleteProjectBranchWithResponse call
func ParseDeleteProjectBranchResponse(rsp *http.Response) (*DeleteProjectBranchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BranchOperations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProjectBranchResponse parses an HTTP response from a GetProjectBranchWithResponse call
func ParseGetProjectBranchResponse(rsp *http.Response) (*GetProjectBranchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BranchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateProjectBranchResponse parses an HTTP response from a UpdateProjectBranchWithResponse call
func ParseUpdateProjectBranchResponse(rsp *http.Response) (*UpdateProjectBranchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BranchOperations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListProjectBranchDatabasesResponse parses an HTTP response from a ListProjectBranchDatabasesWithResponse call
func ParseListProjectBranchDatabasesResponse(rsp *http.Response) (*ListProjectBranchDatabasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectBranchDatabasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatabasesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateProjectBranchDatabaseResponse parses an HTTP response from a CreateProjectBranchDatabaseWithResponse call
func ParseCreateProjectBranchDatabaseResponse(rsp *http.Response) (*CreateProjectBranchDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectBranchDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DatabaseOperations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteProjectBranchDatabaseResponse parses an HTTP response from a DeleteProjectBranchDatabaseWithResponse call
func ParseDeleteProjectBranchDatabaseResponse(rsp *http.Response) (*DeleteProjectBranchDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectBranchDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatabaseOperations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProjectBranchDatabaseResponse parses an HTTP response from a GetProjectBranchDatabaseWithResponse call
func ParseGetProjectBranchDatabaseResponse(rsp *http.Response) (*GetProjectBranchDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectBranchDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatabaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateProjectBranchDatabaseResponse parses an HTTP response from a UpdateProjectBranchDatabaseWithResponse call
func ParseUpdateProjectBranchDatabaseResponse(rsp *http.Response) (*UpdateProjectBranchDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectBranchDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DatabaseOperations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListProjectBranchEndpointsResponse parses an HTTP response from a ListProjectBranchEndpointsWithResponse call
func ParseListProjectBranchEndpointsResponse(rsp *http.Response) (*ListProjectBranchEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectBranchEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListProjectBranchRolesResponse parses an HTTP response from a ListProjectBranchRolesWithResponse call
func ParseListProjectBranchRolesResponse(rsp *http.Response) (*ListProjectBranchRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectBranchRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RolesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateProjectBranchRoleResponse parses an HTTP response from a CreateProjectBranchRoleWithResponse call
func ParseCreateProjectBranchRoleResponse(rsp *http.Response) (*CreateProjectBranchRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectBranchRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RoleOperations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteProjectBranchRoleResponse parses an HTTP response from a DeleteProjectBranchRoleWithResponse call
func ParseDeleteProjectBranchRoleResponse(rsp *http.Response) (*DeleteProjectBranchRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectBranchRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleOperations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProjectBranchRoleResponse parses an HTTP response from a GetProjectBranchRoleWithResponse call
func ParseGetProjectBranchRoleResponse(rsp *http.Response) (*GetProjectBranchRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectBranchRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseResetProjectBranchRolePasswordResponse parses an HTTP response from a ResetProjectBranchRolePasswordWithResponse call
func ParseResetProjectBranchRolePasswordResponse(rsp *http.Response) (*ResetProjectBranchRolePasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetProjectBranchRolePasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleOperations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProjectBranchRolePasswordResponse parses an HTTP response from a GetProjectBranchRolePasswordWithResponse call
func ParseGetProjectBranchRolePasswordResponse(rsp *http.Response) (*GetProjectBranchRolePasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectBranchRolePasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RolePasswordResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetPrimaryProjectBranchResponse parses an HTTP response from a SetPrimaryProjectBranchWithResponse call
func ParseSetPrimaryProjectBranchResponse(rsp *http.Response) (*SetPrimaryProjectBranchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetPrimaryProjectBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BranchOperations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListProjectEndpointsResponse parses an HTTP response from a ListProjectEndpointsWithResponse call
func ParseListProjectEndpointsResponse(rsp *http.Response) (*ListProjectEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateProjectEndpointResponse parses an HTTP response from a CreateProjectEndpointWithResponse call
func ParseCreateProjectEndpointResponse(rsp *http.Response) (*CreateProjectEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProjectEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EndpointOperations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteProjectEndpointResponse parses an HTTP response from a DeleteProjectEndpointWithResponse call
func ParseDeleteProjectEndpointResponse(rsp *http.Response) (*DeleteProjectEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointOperations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProjectEndpointResponse parses an HTTP response from a GetProjectEndpointWithResponse call
func ParseGetProjectEndpointResponse(rsp *http.Response) (*GetProjectEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateProjectEndpointResponse parses an HTTP response from a UpdateProjectEndpointWithResponse call
func ParseUpdateProjectEndpointResponse(rsp *http.Response) (*UpdateProjectEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointOperations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStartProjectEndpointResponse parses an HTTP response from a StartProjectEndpointWithResponse call
func ParseStartProjectEndpointResponse(rsp *http.Response) (*StartProjectEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartProjectEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointOperations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSuspendProjectEndpointResponse parses an HTTP response from a SuspendProjectEndpointWithResponse call
func ParseSuspendProjectEndpointResponse(rsp *http.Response) (*SuspendProjectEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SuspendProjectEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndpointOperations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListProjectOperationsResponse parses an HTTP response from a ListProjectOperationsWithResponse call
func ParseListProjectOperationsResponse(rsp *http.Response) (*ListProjectOperationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectOperationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Operations []Operation `json:"operations"`

			// Pagination Cursor based pagination is used. The user must pass the cursor as is to the backend.
			// For more information about cursor based pagination, see
			// https://learn.microsoft.com/en-us/ef/core/querying/pagination#keyset-pagination
			Pagination *Pagination `json:"pagination,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProjectOperationResponse parses an HTTP response from a GetProjectOperationWithResponse call
func ParseGetProjectOperationResponse(rsp *http.Response) (*GetProjectOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OperationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest GeneralError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
